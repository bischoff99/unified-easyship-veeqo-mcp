# Cursor AI Rules for Unified EasyPost-Veeqo MCP Server

## Project Overview

This is a unified MCP (Model Context Protocol) server that integrates EasyPost and Veeqo shipping APIs for comprehensive shipping, inventory, and orchestration capabilities.

## Code Style & Standards

- Use TypeScript with strict type checking (`strict: true` in tsconfig.json)
- Follow ES modules (import/export) syntax
- Use async/await for all asynchronous operations
- Implement proper error handling with custom error codes
- Use pino for structured logging with appropriate log levels
- Follow RESTful API patterns for external service integration
- Use meaningful variable and function names
- Prefer const over let, avoid var
- Use template literals for string interpolation
- Implement proper TypeScript interfaces for all data structures
- Use Zod for runtime type validation
- Implement proper null/undefined checks
- Use readonly for immutable data structures
- Prefer composition over inheritance

## Architecture Guidelines

- Keep client classes separate from business logic
- Use dependency injection for API clients
- Implement proper retry logic with exponential backoff
- Use idempotency keys for POST operations
- Mock responses for development/testing when API key is "mock"

## Environment Variables

- EASYPOST_API_KEY: Required for EasyPost API access (use "mock" for testing)
- VEEQO_API_KEY: Required for Veeqo API access
- LOG_LEVEL: Logging level (default: "info")
- NODE_ENV: Environment mode (development/production)

## API Integration Rules

- Always validate input parameters using Zod schemas
- Implement proper rate limiting and retry logic
- Use appropriate HTTP status codes and error messages
- Handle API timeouts gracefully (30s default)
- Log all external API calls with request/response details
- Implement circuit breaker pattern for external API calls
- Use idempotency keys for POST operations
- Implement proper request/response logging
- Handle rate limiting with exponential backoff
- Validate all API responses against expected schemas

## MCP Server Guidelines

- Use JSON-RPC 2.0 protocol for all MCP communications
- Implement proper tool registration and schema validation
- Return structured responses with appropriate content types
- Handle tool execution errors gracefully
- Use UUID for request tracking

## Testing & Development

- Use mock responses when EASYPOST_API_KEY=mock
- Implement comprehensive error handling
- Use structured logging for debugging
- Follow the existing tool pattern for new MCP tools

## Security Considerations

- Never log API keys or sensitive data
- Use proper authentication headers
- Implement request validation
- Handle errors without exposing internal details

## File Organization

- Keep tools in src/tools/ directory
- Use schemas in src/schemas/ for validation
- Keep utilities in src/utils/ directory
- Use proper TypeScript types and interfaces

## Performance

- Implement connection pooling for external APIs
- Use appropriate timeouts for all requests
- Cache frequently accessed data when appropriate
- Monitor and log performance metrics

## AI Integration

- Use MCP (Model Context Protocol) for AI tool integration
- Implement intelligent shipping optimization algorithms
- Provide data-driven recommendations based on shipping patterns
- Use structured prompts for consistent AI responses

## Documentation

- Document all public APIs and interfaces
- Include examples for complex operations
- Maintain up-to-date README and API documentation
- Use JSDoc comments for functions and classes

## Git Workflow

- Use conventional commit messages
- Create feature branches for new functionality
- Write descriptive commit messages
- Use pull requests for code review

## Deployment

- Use Railway for cloud deployment
- Implement proper health checks
- Use environment-specific configurations
- Monitor application performance and errors

## Code Generation Guidelines

- Always generate complete, runnable code examples
- Include proper error handling in all generated functions
- Add JSDoc comments for all public functions and classes
- Use consistent naming conventions (camelCase for variables, PascalCase for classes)
- Generate TypeScript interfaces for all API responses
- Include input validation using Zod schemas
- Add proper logging statements for debugging

## File Structure Conventions

- Use kebab-case for file names (e.g., `shipping-tools.ts`)
- Group related functionality in dedicated directories
- Keep configuration files in the root directory
- Use index.ts files for clean exports
- Separate concerns: tools, schemas, utilities, and services

## Error Handling Patterns

- Use custom error classes that extend Error
- Include error codes for programmatic error handling
- Log errors with appropriate context and stack traces
- Return meaningful error messages to clients
- Implement circuit breaker patterns for external API calls

## Testing Requirements

- Write unit tests for all business logic
- Use mock data for external API dependencies
- Test error scenarios and edge cases
- Maintain test coverage above 80%
- Use descriptive test names that explain the scenario

## Performance Optimization

- Implement request caching where appropriate
- Use connection pooling for database/external API connections
- Optimize bundle size by using tree shaking
- Implement lazy loading for non-critical modules
- Monitor and log performance metrics

## Security Best Practices

- Validate all input data using Zod schemas
- Sanitize user inputs to prevent injection attacks
- Use environment variables for sensitive configuration
- Implement rate limiting for API endpoints
- Log security events for monitoring

## Documentation Standards

- Write clear README files with setup instructions
- Document all environment variables and their purposes
- Include API documentation with examples
- Maintain changelog for version tracking
- Use inline comments for complex business logic
